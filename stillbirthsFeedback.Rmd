---
title: "Feedback on Stillbirths Maps"
author: "Ernest Guevarra"
date: "16/08/2018"
output: pdf_document
geometry: margin=2cm
classoption: a4paper
fontsize: 12pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

if(!require(devtools)) install.packages("devtools")
if(!require(papuanewguinea)) install_github("OMNeoHealth/papuanewguinea")
if(!require(kableExtra)) install.packages("kableExtra")
if(!require(maptools)) install.packages("maptools")
if(!require(rgdal)) install.packages("rgdal")
if(!require(rgeos)) install.packages("rgeos")
if(!require(raster)) install.packages("raster")
if(!require(classInt)) install.packages("classInt")

pdata <- read.csv("provincedata.csv")
pdata2015 <- pdata[pdata$year == 2015, ]
pdata2016 <- pdata[pdata$year == 2016, ]
```

## File naming

Always make sure that you don't use filenames with spaces. Too much use of Microsoft Word has trained us that the filename of a document can be as long and can have spaces. Unfortunately, it is very hard to work with filenames with spaces especially when working with code. Remember what we discussed in the workshop about file naming conventions. either use an underscore if you really want to have a space in the filename or use the camel case naming syntax (see https://en.wikipedia.org/wiki/Camel_case)

I woudl suggest renaming the `Stillbirths maps.R` file differently. With camel case syntax, you can opt for `stillbirthsMaps.R`. With underscore, it can be `stillbirths_maps.R`.

## Line by line feedback

### Line 4

In line 4 of the script, you wrote:

```{r, echo = TRUE, eval = FALSE}
write.csv(provincedata, "districtdata.csv", row.names = FALSE)
```

I think here you  meant to write the object named `districtdata` into a CSV file called `districtdata.csv`. So the script should read:

```{r, echo = TRUE, eval = FALSE}
write.csv(district, "districtdata.csv", row.names = FALSE)
```

### Lines 25, 26, 31

```{r, echo = TRUE, eval = FALSE}
#
# stillbirths
#
still2015p <- pdata2015$still
still2016p <- pdata2016$still

#
# create variable females in province
#
femprov <- pop_adm1$FEMALES
```

You don't always have to create variables/objects for single values that you want to use from a data frame. If you do so, you will end up with so many objects in your workspace that you will only probably use once. You can simply make a call to these variables by indexing (using square brackets) or using the `$` syntax whenever you need them.

### Lines 31, 35-36

```{r, echo = TRUE, eval = FALSE}
#
# create variable females in province
#
femprov <- pop_adm1$FEMALES

# use femprov to normalise maternal deaths per province

still2015p <- (pdata2015$still/femprov)*100000
still2016p <- (pdata2016$still/femprov)*100000
```

Here, I think you are trying to normalise the stillbirths count using the number of female population per province. Specifically, you are normalising it to a rate of number of stillbirths per 100,000 females. Is that correct?

First comment here is that it might be better to use the number of women of reproductive age as your normalising value. This value is available in `pop_adm1` in the column named `WRA`.

Second, you will notice that the population data in `pop_adm1` has a different order of provinces as compared to `pdata2015`.

```{r, echo = FALSE, eval = TRUE}
kable(x = pop_adm1,
      booktabs = TRUE,
      format = "latex") %>%
  kable_styling(latex_options = c("HOLD_position", "striped", "scale_down"))
```

```{r, echo = FALSE, eval = TRUE}
kable(x = pdata2015[ , 1:15],
      booktabs = TRUE,
      format = "latex") %>%
  kable_styling(latex_options = c("HOLD_position", "striped", "scale_down"))
```

The province data goes province with code 1 to code 22 while the population data is a little bit mixed up in that the `ADM1_PCODE` values go from `PG01` to `PG07` and then `PG21`, `PG08`, `PG22` and then `PG09` to `PG20`. This means that simply doing a straight division as you did in lines 35 and 36 would mean dividing some provinces with code 8 onwards with the wrong normalising population value.

To address this, one solution is to sort `pop_adm1` data frame in such a way that it goes from 1-22 province code order. This can be done as follows:

```{r, echo = TRUE, eval = TRUE}
pop_adm1 <- pop_adm1[order(pop_adm1$ADM1_PCODE), ]
```

What this command does is that it orders the variable `ADM1_PCODE` from `PG01` to `PG22` and then sorts `pop_adm1` data frame based on this new ordering.

The resulting data frame is:

```{r, echo = FALSE, eval = TRUE}
kable(x = pop_adm1,
      booktabs = TRUE,
      format = "latex") %>%
  kable_styling(latex_options = c("HOLD_position", "striped", "scale_down"))
```

You will now notice that the order of the provinces is from `PG01` to `PG22`, the same order that we have for `pdata2015` and `pdata2016`. Once it has been ordered this way, The stillbirths data can now be normalised using the women of reproductive age populations using the following commands.

```{r, echo = TRUE, eval = TRUE, results = FALSE}
still2015p <- (pdata2015$still/pop_adm1$WRA) * 100000
still2016p <- (pdata2016$still/pop_adm1$WRA) * 100000
```


### Lines 38 - 39, 41 - 42

```{r, echo = TRUE, eval = FALSE}
pop2015 <- data.frame("pcode" = 1:22, "pop2015" = pdata2015$still)
pop2016 <- data.frame("pcode" = 1:22, "pop2016" = pdata2016$still)

pdata2015 <- merge(pdata2015, pop2015, by = "pcode")
pdata2016 <- merge(pdata2016, pop2016, by = "pcode")
```

In these commands, what I think  you are trying to do is to create a data frame for the stillbirths data.

The main issue with this is that you are still using the non-normalised stillbirth data instead of the normalised stillbirth data that you have just calculated. Also, it might be more informative to call this new data frame as `still2015` and `still2016` rather than `pop2015` and `pop2016` So, the more appropriate command would be:

```{r, echo = TRUE, eval = FALSE}
still2015 <- data.frame("pcode" = 1:22, "still2015" = still2015p)
still2016 <- data.frame("pcode" = 1:22, "still2016" = still2016p)
```

And then, these can now be merged to the province data as follows:

```{r, echo = TRUE, eval = FALSE}
pdata2015 <- merge(pdata2015, still2015, by = "pcode")
pdata2016 <- merge(pdata2016, still2016, by = "pcode")
```

### Lines 44-73

```{r, echo = TRUE, eval = FALSE}
# map stillbirths per province normalised by total women per province x 100000
#
# first create classification of stillbirths for each year
#
still2015pclass <- base::cut(x = still2015p, 
                             breaks = c(0, 10, 20, 40, 60, 80, 100), 
                             labels = FALSE)

still2016pclass <- base::cut(x=still2016p, 
                             breaks = c(0, 10, 20, 40, 60, 80, 100), 
                             labels = FALSE)

# create colourscheme and provide color for classification per province 
# of mat deaths
colourscheme <- c("#eff3ff", "#c6dbef", "#9ecae1", 
                  "#6baed6", "#3182bd", "#08519c")

plot (province, lwd = 1, border = "gray50", 
      col = ifelse(still2015pclass == 0, colourscheme[1],
              ifelse(still2015pclass == 1, colourscheme[2],
                ifelse(still2015pclass == 2, colourscheme[3],
                  ifelse(still2015pclass == 3, colourscheme[4],
                    ifelse(still2015pclass == 4, colourscheme[5],
                      ifelse(still2015pclass == 5, colourscheme[6], 
                             colourscheme[7])))))))

plot (province, lwd = 1, border = "gray50", 
      col = ifelse(still2016pclass == 0, colourscheme[1],
              ifelse(still2016pclass == 1, colourscheme[2],
                ifelse(still2016pclass == 2, colourscheme[3],
                  ifelse(still2016pclass == 3, colourscheme[4],
                    ifelse(still2016pclass == 4, colourscheme[5],
                      ifelse(still2016pclass == 5, colourscheme[6], 
                             colourscheme[7])))))))
```

There are a lot of issues with these lines of code.

First, in grouping/classifying the normalised stillbirths, you will need to see the range of values for the normalised stillbirths. In the way you have classified them, you assume that the maximum value is 100. However, the normalised values for stillbirhts goes beyond 100. To see the range of normalised stillbirth values, you can create a simple summary:

```{r, echo = TRUE, eval = TRUE}
summary(still2015p)
summary(still2016p)
```

To address this, we will have to use an approach in which the normalised stillbirth counts are grouped into meaningful classes. A useful approach will be using quantiles. For this, we can use the R package called `classInt` which has a function called `classIntervals()`. To install `classInt`, run the following commands:

```{r, echo = TRUE, eval = FALSE}
install.packages("classInt")
```

Once installed, you can now use the `classIntervals()` function to create 5 classes from the normalised stillbirth values:

```{r, echo = TRUE, eval = TRUE}
#
# 2015 data
#
still2015classes <- cut(x = still2015p,
                        breaks = classIntervals(var = still2015p, 
                                                n = 5, 
                                                style = "quantile")$brks,
                        labels = FALSE)
#
# Recode NA class to 0
#
still2015classes <- ifelse(is.na(still2015classes), 0, still2015classes)
#
# 2016 data
#
still2016classes <- cut(x = still2016p,
                        breaks = classIntervals(var = still2016p, 
                                                n = 5, 
                                                style = "quantile")$brks,
                        labels = FALSE)
#
# Recode NA class to 0
#
still2016classes <- ifelse(is.na(still2016classes), 0, still2016classes)
```

Now for mapping the stillbirths, we first need to relate the stillbirths data with the map. This means making sure that the map data is also ordered in the same way as the stillbirths data. We know that the stillbirthsdata is ordered from the province with code 1 to province with code 22. Now we need to inspect the map data. We can do this as follows:

```{r, echo = TRUE, eval = TRUE}
province@data
```

Here we can see that the province map data is not ordered from code 1 to 22. We will therefore have to order it in a similar way that we did the ordering for `pop_adm1`. This can be done as follows:

```{r, echo = TRUE, eval = TRUE}
province@data <- province@data[order(province@data$ADM1_PCODE), ]
```

This orders the provinces in the map data based on their code from 1 to 22. This data is now in the same order as our stillbirths data as shown below:

```{r, echo = FALSE, eval = TRUE}
province@data
```

Now we can map the stillbirths for 2015 data as follows:

```{r, echo = TRUE, eval = TRUE, fig.align = "center", fig.pos = "H", fig.width = 6, fig.height = 6}

colourscheme <- c("#eff3ff", "#c6dbef", "#9ecae1", 
                  "#6baed6", "#3182bd", "#08519c")

plot(province,
     col = colourscheme[still2015classes + 1],
     border = "gray90",
     lwd = 0.5)
```

\newpage

To map both 2015 and 2016, we can plot these maps side-by-side in order to make comparisons. This can be done as follows:

```{r, echo = TRUE, eval = TRUE, fig.align = "center", fig.pos = "H", fig.width = 14, fig.height = 7}
par(mar = c(0, 0, 0, 0), mfrow = c(1, 2))
plot(province,
     col = colourscheme[still2015classes + 1],
     border = "gray90",
     lwd = 0.5)
plot(province,
     col = colourscheme[still2016classes + 1],
     border = "gray90",
     lwd = 0.5)
```

Now, it will be useful to add a title to each plot to identify which map is for which year and to add a legend to show what the colours refer to. This can be done as follows:

```{r, echo = TRUE, eval = TRUE, message = FALSE, fig.align = "center", fig.pos = "H", fig.width = 14, fig.height = 7}
par(mar = c(0, 0, 0, 0), mfrow = c(1, 2))
plot(province,
     col = colourscheme[still2015classes + 1],
     border = "gray90",
     lwd = 0.5)
title(main = "Stillbirths 2015", line = -1, adj = 1)
legend(x = "bottomright",
       inset = 0.1,
       y.intersp = 1.2,
       legend = c("0", names(print(classIntervals(still2015p,
                                                  n = 5,
                                                  style = "quantile",
                                                  dataPrecision = 0), 
                                   between = "to", 
                                   cutlabels = FALSE))),
       pch = 15, pt.cex = 2,
       col = colourscheme)
plot(province,
     col = colourscheme[still2016classes + 1],
     border = "gray90",
     lwd = 0.5)
title(main = "Stillbirths 2016", line = -1, adj = 1)
legend(x = "bottomright",
       inset = 0.1,
       y.intersp = 1.2,
       legend = c("0", names(print(classIntervals(still2016p, 
                                                  n = 5,
                                                  style = "quantile",
                                                  dataPrecision = 0), 
                                   between = "to", 
                                   cutlabels = FALSE))),
       pch = 15, pt.cex = 2,
       col = colourscheme)
```

Now, you might want to use the same classes for each map so that they can be compared with each other. To do this, we will need to create the classes using the normalised stillbirth values for 2015 and 2016. This can be done as follows:

```{r, echo = TRUE, eval = TRUE}
#
# 2015 data
#
still2015classes <- cut(x = still2015p,
                        breaks = classIntervals(var = c(still2015p, still2016p),  
                                                n = 5, 
                                                style = "quantile")$brks,
                        labels = FALSE)
#
# Recode NA class to 0
#
still2015classes <- ifelse(is.na(still2015classes), 0, still2015classes)
#
# 2016 data
#
still2016classes <- cut(x = still2016p,
                        breaks = classIntervals(var = c(still2015p, still2016p), 
                                                n = 5, 
                                                style = "quantile")$brks,
                        labels = FALSE)
#
# Recode NA class to 0
#
still2016classes <- ifelse(is.na(still2016classes), 0, still2016classes)
```

Using these new classes, the map can be mapped again with using these new classifications.

```{r, echo = TRUE, eval = TRUE, message = FALSE, fig.align = "center", fig.pos = "H", fig.width = 14, fig.height = 7}
par(mar = c(0, 0, 0, 0), mfrow = c(1, 2))
plot(province,
     col = colourscheme[still2015classes + 1],
     border = "gray90",
     lwd = 0.5)
title(main = "Stillbirths 2015", line = -1, adj = 1)
legend(x = "bottomright",
       inset = 0.1,
       y.intersp = 1.2,
       legend = c("0", names(print(classIntervals(c(still2015p, still2015p),
                                                  n = 5,
                                                  style = "quantile",
                                                  dataPrecision = 0), 
                                   between = "to", 
                                   cutlabels = FALSE))),
       pch = 15, pt.cex = 2,
       col = colourscheme)
plot(province,
     col = colourscheme[still2016classes + 1],
     border = "gray90",
     lwd = 0.5)
title(main = "Stillbirths 2016", line = -1, adj = 1)
legend(x = "bottomright",
       inset = 0.1,
       y.intersp = 1.2,
       legend = c("0", names(print(classIntervals(c(still2015p, still2015p), 
                                                  n = 5,
                                                  style = "quantile",
                                                  dataPrecision = 0), 
                                   between = "to", 
                                   cutlabels = FALSE))),
       pch = 15, pt.cex = 2,
       col = colourscheme)
```
